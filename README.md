# Leetcode-tree
## 94题 Binary Tree Inorder Traversal
对于树的问题，大多数我们都会使用递归的方法。原因是树的左子树也是树，右子树也是树，使用递归的方法最简单快捷。这道题是需要我们用Inorder的顺序输出节点。inorder的顺序是先左再自己再右。那么对于任意一个结点我们处理的方式都是先处理左子树再处理自己再处理右子树。那么我们可以总结出一个senario：
1. 处理左子树
2. 添加自己的val值
3. 处理右子树
## 100题 same tree
这道题也是使用递归的方法，我们只需先将树为空的特例显示出来。
1. 两个树均为空 return true
2. 其中一个为空 return false
3. 两个结点的值不同 return false
4. 递归判断子树是否为same tree
## 101题 symmetric tree
方法与100题方法相同
## 102题 Binary Tree Level Order Traversal
这道题我们使用了queue先进先出的一个数据结构，通过判断queue的size我们就可以知道这一层需要输出的元素个数。并且在读取每一个结点的时候我们都会查询该节点是否有children，如果有那么把他们压入队列。
## 104题 Maximum Depth of Binary Tree
这道题我们使用的还是递归的方法，整个树的深度等于左子树深度和右子树深度的最大值加上1，这个1代表根节点。
## 107题 Binary Tree Level Order Traversal II
这道题是102题的变形，不同的是他要求我们倒序输出。基本方法和102题是相同，我们只需要再使用一个stack先进后出的结构输出结果即可。
## 110题 Balanced Binary Tree
这道题我们首先需要了解平衡二叉树的定义：是一颗空树 || 它左右两个子树的高度差不超过1 && 左右两个子树都是平衡二叉树
同样我们可以使用递归的方法，计算二叉树高度时我们可以使用104题的方法。
## 111题 Minimum Depth of Binary Tree
这道题是让我们寻找到叶结点的最短路径。这里我们需要考虑几种情况：
1. 根节点为空 return 0
2. 当访问到的子节点为空时，说明该结点无效，赋值Integer.MAX_VALUE
3. 当访问的结点没有孩子时，说明只有一层，return 1
4. 其他情况最小深度等于左子树的最小深度和右子树最小深度的最小值再加1，这个1代表根节点。
## 144题 preorder
## 145题 postorder
这两道题与94题的解题思路是一样的。preorder只需将顺序改为先处理自己，再处理左子树，最后处理右子树。postorder需要将顺序改为先处理左子树，再处理右子树，最后处理自己。
