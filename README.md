# Leetcode-tree
## 94题 Binary Tree Inorder Traversal
对于树的问题，大多数我们都会使用递归的方法。原因是树的左子树也是树，右子树也是树，使用递归的方法最简单快捷。这道题是需要我们用Inorder的顺序输出节点。inorder的顺序是先左再自己再右。那么对于任意一个结点我们处理的方式都是先处理左子树再处理自己再处理右子树。那么我们可以总结出一个senario：
1. 处理左子树
2. 添加自己的val值
3. 处理右子树
## 96题 Unique Binary Search Trees
这道题我们使用了动态规划的方法。说到动态规划我们这里先总结一下动态规划类型的题该如何做。
动态规划题目特点：
1. 计数型：  
-有多少中方式走到右下角  
-有多少种方法选出k个数使得和是sum
2. 求最大最小值：  
-从左上角走到右下角路径的最大数字和  
-最长上升子序列长度
3. 求存在性  
-取石子游戏，先手是否必胜  
-能不能选出k个数使得和是sum  

·动态规划组成部分一：确定状态  
简单说，解动态规划的时候需要开一个数组，数组的每个元素代表什么。  
数组开多大，若需要使用0……..n 那么int[] dp = new int[n+1] 若需要使用0…….n-1那么开到n  
确定状态需要两个意识：  
  -最后一步  
  -化成子问题  
如何避免重复计算，将计算结果保留，并改变计算顺序。  
·动态规划组成部分二：转移方程  
·动态规划组成部分三：初始条件和边界情况  
初始条件：用转移方程算不出来，需要手工定义。  
·动态规划组成部分四：计算顺序  
当计算转移方程的左边时，右边的所有参数已经得到了结果。

针对这道题：
1. 确定状态：我们需要开辟一个一维数组，代表n个结点能有多少个unique binary search tree
2. 转移方程：若我们使用n代表有多少个结点，j代表左子树的结点树，那么n-j-1就代表右子树的节点数。那么我们可以得出我们的转移方程：从j=0到j=n对dp[j] * dp[n-j-1]进行求和
3. 初始条件和边界情况：我们将结点为0时赋值为1，结点为1时也赋值为1.
4. 计算顺序：从小到大进行计算
## 100题 same tree
这道题也是使用递归的方法，我们只需先将树为空的特例显示出来。
1. 两个树均为空 return true
2. 其中一个为空 return false
3. 两个结点的值不同 return false
4. 递归判断子树是否为same tree
## 101题 symmetric tree
方法与100题方法相同
## 102题 Binary Tree Level Order Traversal
这道题我们使用了queue先进先出的一个数据结构，通过判断queue的size我们就可以知道这一层需要输出的元素个数。并且在读取每一个结点的时候我们都会查询该节点是否有children，如果有那么把他们压入队列。
## 104题 Maximum Depth of Binary Tree
这道题我们使用的还是递归的方法，整个树的深度等于左子树深度和右子树深度的最大值加上1，这个1代表根节点。
## 107题 Binary Tree Level Order Traversal II
这道题是102题的变形，不同的是他要求我们倒序输出。基本方法和102题是相同，我们只需要再使用一个stack先进后出的结构输出结果即可。
## 110题 Balanced Binary Tree
这道题我们首先需要了解平衡二叉树的定义：是一颗空树 || 它左右两个子树的高度差不超过1 && 左右两个子树都是平衡二叉树
同样我们可以使用递归的方法，计算二叉树高度时我们可以使用104题的方法。
## 111题 Minimum Depth of Binary Tree
这道题是让我们寻找到叶结点的最短路径。这里我们需要考虑几种情况：
1. 根节点为空 return 0
2. 当访问到的子节点为空时，说明该结点无效，赋值Integer.MAX_VALUE
3. 当访问的结点没有孩子时，说明只有一层，return 1
4. 其他情况最小深度等于左子树的最小深度和右子树最小深度的最小值再加1，这个1代表根节点。
## 144题 preorder / 145题 postorder
这两道题与94题的解题思路是一样的。preorder只需将顺序改为先处理自己，再处理左子树，最后处理右子树。postorder需要将顺序改为先处理左子树，再处理右子树，最后处理自己。
